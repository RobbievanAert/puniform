{
    "contents" : "#' escompute\n#'\n#' Function that computes Hedges' g and its sampling variance for an one-sample mean and a two-independent means, Fisher's r-to-z transformed correlation coefficient and its sampling variance for a raw correlation coefficient and computes a p-value as in the primary studies was done.\n#'\n#' @param mi A vector of group means for one-sample mean\n#' @param ni A vector of sample sizes for one-sample mean\n#' @param sdi A vector of standard deviations for one-sample mean\n#' @param m1i A vector of means in group 1 for two-independent means\n#' @param m2i A vector of means in group 2 for two-independent means\n#' @param n1i A vector of sample sizes in group 1 for two-independent means\n#' @param n2i A vector of sample sizes in group 2 for two-independent means\n#' @param sd1i A vector of standard deviations in group 1 for two-independent means\n#' @param sd2i A vector of standard deviations in group 2 for two-independent means\n#' @param ri A vector of raw correlation coefficients\n#' @param tobs A vector of t-values\n#' @param yi A vector of standardized effect sizes\n#' @param vi A vector of sampling variances belonging to the standardized effect sizes (\\code{yi})\n#' @param alpha A integer specifying the alpha level as used in primary studies\n#' @param side A character indicating the direction of the tested hypothesis in the primary studies (either \"\\code{right}\" or \"\\code{left}\")\n#' @param measure A character indicating what kind of effect size should be computed (Hedges' g or Fisher's r-to-z transformed correlation coefficients) and which arguments are used as input (\"\\code{M}\", \"\\code{MT}\", \"\\code{MD}\", \"\\code{MDT}\", or \"\\code{COR}\"). See Details below.\n#'\n#' @details The \\code{measure} argument has to be used to specify the desired effect size and what input parameters are used. There are six options:\n#' \\itemize{\n#' \\item{\\code{\"M\"}}{ for one-sample mean with \\code{mi}, \\code{ni}, \\code{sdi}, \\code{alpha}, and \\code{side} as input parameters}\n#' \\item{\\code{\"MT\"}}{ for one-sample mean with \\code{tobs}, \\code{ni}, \\code{alpha}, and \\code{side} as input parameters}\n#' \\item{\\code{\"MD\"}}{ for two-sample mean with \\code{m1i}, \\code{m2i}, \\code{n1i}, \\code{n2i}, \\code{sd1i}, \\code{sd2i}, \\code{alpha}, and \\code{side} as input parameters}\n#' \\item{\\code{\"MDT\"}}{ for two-sample mean with \\code{tobs}, \\code{n1i}, \\code{n2i}, \\code{alpha}, and \\code{side} as input parameters}\n#' \\item{\\code{\"COR\"}}{ for raw correlation coefficients with \\code{ri}, \\code{ni}, \\code{alpha}, and \\code{side} as input parameters}\n#' \\item{\\code{\"SPE\"}}{ for user-specified standardized effect sizes and sampling variances with \\code{yi}, \\code{vi}, \\code{alpha}, and \\code{side} as input parameters}\n#' }\n#'\n#' @return Function returns a data frame with standardized effect sizes (yi), variances of these standardized effect sizes (vi), z-values (zval), p-values as computed in primary studies (pval), and critical z-values (zcv).\n#'\n#' @author Robbie C.M. van Aert \\email{R.C.M.vanAert@@tilburguniversity.edu}\n#'\n#' @export\n\nescompute <- function(mi, ri, ni, sdi, m1i, m2i, n1i, n2i, sd1i, sd2i, tobs, yi, vi, alpha, side, measure) {\n\n  if (measure == \"M\" | measure == \"MT\") {\n    if (measure == \"M\") {\n      di <- mi/sdi\n      tval <- mi/(sdi/sqrt(ni))\n    } else if (measure == \"MT\") {\n      di <- tobs*(1/sqrt(ni))\n      tval <- tobs\n    }\n    J <- 1 - 3/(4*(ni-1)-1)\n    yi <- J * di\n    vi <- J^2 * (1/ni+di^2/(2*ni))\n    zval <- yi/sqrt(vi)\n    if (side == \"right\") { pval <- pt(tval, df = ni - 1, lower.tail = FALSE) }\n    if (side == \"left\") { pval <- pt(tval, df = ni - 1) }\n    dcvi <- qt(alpha, df = ni-1, lower.tail = FALSE)*1/sqrt(ni)\n    ycvi <- J * dcvi\n    zcv <- ycvi/sqrt(vi)\n  }\n\n  else if (measure == \"MD\" | measure == \"MDT\") {\n    if (measure == \"MD\") {\n      s.pool <- sqrt(((n1i-1)*sd1i^2 + (n2i-1)*sd2i^2)/(n1i+n2i-2))\n      di <- (m1i-m2i)/s.pool\n      tval <- (m1i - m2i)/sqrt(s.pool^2*(1/n1i+1/n2i))\n    } else if (measure == \"MDT\") {\n      di <- tobs*sqrt((n1i+n2i)/(n1i*n2i))\n      tval <- tobs\n    }\n    J <- 1 - 3/(4*(n1i+n2i-2)-1)\n    yi <- J * di\n    vi <- 1/n1i+1/n2i+(1-(n1i+n2i-2-2)/((n1i+n2i-2)*J^2))*yi^2\n    zval <- yi/sqrt(vi)\n    if (side == \"right\") { pval <- pt(tval, df = n1i+n2i-2, lower.tail = FALSE) }\n    if (side == \"left\") { pval <- pt(tval, df = n1i+n2i-2) }\n    dcvi <- qt(alpha, df = n1i+n2i-2, lower.tail = FALSE)*sqrt((n1i+n2i)/(n1i*n2i))\n    ycvi <- J * dcvi\n    zcv <- ycvi/sqrt(vi)\n  }\n\n  else if (measure == \"COR\") {\n    yi <- .5*log((1 + ri) / (1 - ri))\n    vi <- 1/(ni-3)\n    zval <- yi/sqrt(vi)\n    if (side == \"right\") { pval <- pnorm(zval, lower.tail = FALSE) }\n    if (side == \"left\") { pval <- pnorm(zval) }\n    zcv <- qnorm(alpha, lower.tail = FALSE)\n  }\n\n  else if (measure == \"SPE\") {\n    zval <- yi/sqrt(vi)\n    if (side == \"right\") { pval <- pnorm(zval, lower.tail = FALSE) }\n    if (side == \"left\") { pval <- pnorm(zval) }\n    zcv <- qnorm(alpha, lower.tail = FALSE)\n  }\n\n  if (side == \"left\") {\n    yi <- yi * -1\n    zval <- zval * -1\n  }\n\n  return(data.frame(yi, vi, zval, pval, zcv))\n}\n",
    "created" : 1455614902802.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3492196655",
    "id" : "B8DF288D",
    "lastKnownWriteTime" : 1455628007,
    "path" : "D:/Dropbox/Werk/Onderzoek/Code/puniform/R/GIT_escompute_4.R",
    "project_path" : "R/GIT_escompute_4.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}